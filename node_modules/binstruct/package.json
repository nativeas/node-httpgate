{
  "name": "binstruct",
  "version": "0.2.0",
  "description": "Read/write binary data structures to/from buffers.",
  "keywords": [
    "binary",
    "bin",
    "buffers",
    "struct",
    "unpack",
    "pack",
    "serialization"
  ],
  "main": "binstruct",
  "repository": {
    "type": "git",
    "url": "http://github.com/dobesv/node-binstruct.git"
  },
  "files": [
    "binstruct.js",
    "AUTHORS",
    "package.json",
    "Readme.md"
  ],
  "engines": {
    "node": ">=0.6.0"
  },
  "contributors": [
    {
      "name": "Dobes Vandermeer",
      "email": "dobesv@gmail.com",
      "url": "http://dobesv.com"
    }
  ],
  "readme": "\n## Binary Structure Helper\n\nThis module helps you work with binary structures in Buffers.\nYou first define the layout of your binary data and then use\nthat definition to convert objects to/from their binary\nrepresentation or you can wrap a buffer with an object where\ngetters/setters for fields update and read the buffer in place.\n\n## Features\n\n - Use the same definition for reading and writing objects\n - Wrap a buffer to use getters/setters to operate directly on\n   Buffer contents\n - Also able to read/write to/from objects\n - \"Fluid API\" structure definition is easy on the eyes\n - Customizable 64-bit integer support\n - Easy big-endian and little-endian support\n - No external dependencies or native extensions required (works in Windows!)\n\n## Requirements\n\nThis module requires node 0.6 or better, as it uses the binary type\nread/write methods on Buffer introduced with node 0.6.\n\n## Numeric Types\n\nAdding numeric fields to the structure definition requires calling\na method with the appropriate type name.\n\nIf a string is passed, it is used as the name of the field, otherwise\nthe field is basically skipped (padding).\n\n - int8, int16, int32, int64: Signed integers\n - byte, uint16, uint32, uint64: Unsigned integers\n - float: 32-bit IEEE floating point number\n - double: 64-bit IEEE floating point number\n\n### Endian-ness / Byte Order\n\nWhen defining a structure, the default is to use \"big endian\"\nbyte order when reading/writing numbers.  You can change the\ndefault by specifying options to the constructor.  For example:\n\n    var littleEndianStruct = require('binstruct')\n        .def({littleEndian:true})\n        .float('littleEndianFloat')\n        .double('littleEndianDouble')\n        .int32('littleEndianInteger');\n\nYou can also specify littleEndian by adding \"le\" to the type names\nas you declare the structure.  For example:\n\n    var littleEndianStruct = require('binstruct')\n        .def()\n        .floatle('littleEndianFloat')\n        .doublele('littleEndianDouble')\n        .int32le('littleEndianInteger');\n\nThis could conceivably allow you to have a mix of little and big endian\nnumbers in the same structure although in practice I doubt that would\never happen.  Rather this may turn out be a shorter syntax when there\nare relatively few fields - adding 'le' a few times could be less\npainful than {littleEndian:true}.\n\n### 64-bit Integers Support\n\nJavascript doesn't normally support 64-bit numbers - all numbers are\nrepresented as a 64-bit floating point value.  This can only represent a\n53-bit signed integer, or a 52-bit unsigned integer correctly.\n\nWhen reading 64-bit integers you can choose whether to convert to a\nJavascript number or to store the number as a buffer.  If converting\nto a number, you can choose whether an overflow should throw an error\nor just set the field to Infinity or -Infinity.  If storing as a\nbuffer you can choose whether it should be a \"slice\" of the original\nbuffer or a copy.\n\n - strict: Convert to js number, throw Error on overflow.  This is the default mode.\n - lossy: Convert to js number, use Infinity/-Infinity on overflow\n - copy: Copy the literal bytes into a Buffer for the field value\n - slice: Field value is a \"slice\" containing the original bytes\n\nTo specify a mode, pass an options object to the initial call to\ndef() or as a parameter to a field definition with a property\n'int64mode' mode set to a value from binstruct.int64modes.  Examples:\n\n    var binstruct = require('binstruct');\n    binstruct.def({int64mode:binstruct.int64modes.lossy});\n    binstruct.def().uint64('a', {int64mode:binstruct.int64modes.copy});\n    binstruct.def().int64('b', {int64mode:binstruct.int64modes.slice});\n\n## Buffer Wrapping\n\nThe library may create a \"wrapper\" around a buffer which allows you\nto read and write the binary fields from the buffer on the fly using\nproperty getters and setters on the wrapper.  This allows for a\npleasant looking syntax for editing fields, and may save some time\nif relatively few fields are actually used by the application.\n\nNote, however, that this access isn't generally very fast, so it is\nbest to minimize the number of property reads and writes you do.\n\nTo create a wrapper call wrap() on your structure definition and\npass a buffer and an optional offset into that buffer at which to\nread the structure.\n\n    var binstruct = require('binstruct');\n    var buf = new Buffer('ab');\n    var twoBytes = binstruct.def()\n        .byte('a')\n        .byte('b')\n        .wrap(buf);\n    assert.equal(String.fromCharCode(twoBytes.a), 'a');\n    assert.equal(String.fromCharCode(twoBytes.b), 'b');\n    twoBytes.a = 'x';\n    twoBytes.b = 'y';\n    assert.equal(String.fromCharCode(buf[0]), 'x');\n    assert.equal(String.fromCharCode(buf[1]), 'y');\n    var offsetBy1 = binstruct.def().byte('b').wrap(buf, 1);\n    assert.equal(String.fromCharCode(offsetBy1.b), 'y');\n\n## Pack/Unpack Buffers To/From Objects\n\nThe library allows you to 'pack' an object into a Buffer and 'unpack'\nan object from a Buffer.\n\nThe 'read' operation goes through all the fields defined and populates\nthem into a new object and returns it.  Unlike with a wrapper, changes to\nthat object will not affect the underlying buffer.\n\nThe 'write' operation goes through all the fields defined and encodes the\nvalues for those fields from the provided object into the target buffer.\n\n    iobuf = new Buffer([1,2,3,4,5,6,7]);\n    var ledef = binstruct.def().uint32le('val').uint16le('short').byte('b');\n    var ledata = ledef.read(iobuf);\n    assert.equal(0x04030201, ledata.val);\n    ledata.val = 0x05060708;\n    ledata.short = 0x090a;\n    ledata.b = 0xb;\n    assert.equal('01020304050607', iobuf.toString('hex'));\n    ledef.write(ledata, iobuf);\n    assert.equal('080706050a090b', iobuf.toString('hex'));\n\n    // Read/write at an offset\n    var iobuf2 = new Buffer([1,2,3,4,5,6,7,8,9,10,11]);\n    ledef.write(ledata, iobuf2, 2);\n    assert.equal(iobuf2.toString('hex'), '0102'+iobuf.toString('hex')+'0a0b');\n\n    // write() with no parameters creates a new buffer\n    assert.equal(ledef.write().toString('hex'), iobuf.toString('hex'));\n\n## Default Values\n\nWhen adding a numeric field you can specify a parameter with a \"default\"\nfor that field.  This will be applied during a write() operation if that\nfield is not provided.\n\n    assert.equal(require('binstruct').def()\n                 .byte(1)\n                 .byte(2)\n                 .write().toString('hex'),\n                 '0102');\n\nWhen using a wrapper you can request that the default values be written\nby calling writeValues() on the result of wrap();\n\n    var buf = new Buffer(2);\n    require('binstruct').def()\n                 .byte(1)\n                 .byte(2)\n                 .wrap(buf)\n                 .writeValues();\n    assert.equal(buf.toString('hex'), '0102');\n\nWhen using a wrapper you can check whether the values in the buffer are\nequal to the default values specified.  This can be helpful if you are\nlooking for a certain \"signature\" in the file that identifies the file\nformat or data structure you are working with.\n\n    assert.doesNotThrow(function() {\n        binstruct.def().uint16(0x0102).wrap(new Buffer([1,2])).checkValues();\n    });\n    assert.throws(function() {\n        binstruct.def().uint16(0x0102).wrap(new Buffer([5,6])).checkValues();\n    });\n\n## Size Check\n\nWhen defining a structure you are probably implementing something from\na third part.  As a sanity check, it's helpful to verify the structure\nyou've defined is the right size.  Do this by adding checkSize(size) to\nthe end of your definition.  For example:\n\n    require('binstruct').def()\n        .uint64('x')\n        .uint32('y') // Simulated copy/paste error using 32 instead of 64\n        .checkSize(16); // throws an error!\n\n## Installation\n\nInstall using npm:\n\n    npm install binstruct\n\n## Future work\n\n - String and buffer fields\n - Sub-structures\n - Arrays of types\n - Dynamically sized arrays, strings, buffers\n - Computed values / sizes (using functions instead of constants)\n\n",
  "readmeFilename": "Readme.md",
  "bugs": {
    "url": "https://github.com/dobesv/node-binstruct/issues"
  },
  "_id": "binstruct@0.2.0",
  "dist": {
    "shasum": "1b6117d430b7142e8ab350b287abb3a8689004c4"
  },
  "_from": "binstruct@0.2.0",
  "_resolved": "https://registry.npmjs.org/binstruct/-/binstruct-0.2.0.tgz"
}
